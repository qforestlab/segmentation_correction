---
title: "Get shapefile crowns with crown area, height and neighbor list"
Author: "Jessie McLean. Adapted from get-shape-file-crowns.Rmd from Geike De Sloover"
output: html_notebook
---


```{r}
library(sf)
library(dplyr)
library(concaveman)
library(ITSMe)
```

```{r}
# Define folder and pattern
folder <- "S:/qfl_australia_tls/Whyanbeel/Propagation/selected_trees"
pattern <- "*.las"

# Get list of files
files <- list.files(path = folder, pattern = pattern, full.names = TRUE, recursive = FALSE)

# Remove files ending in remainder.las as this is the left over point cloud
files <- files[!grepl("remainder\\.las$", files)]
```

```{r}
process_file <- function(file) {
  # Read point cloud
  print(file)
  pc <- read_tree_pc(file)
  concavity <- 2
  
  hull <- NA
  pa <- NA
  height <- NA
  
  if (nrow(pc) != 0) {
    points <- st_as_sf(unique(pc[1:2]), coords = c("X", "Y"))
    hull <- concaveman::concaveman(points, concavity)
    pa <- st_area(hull)
    height_list <- tree_height_pc(pc) # List with the tree height (numeric value) and the determined lowest point (lp, numeric value)
    height <- height_list[1] #just taking the tree height
  }
  
  full_name <- tools::file_path_sans_ext(basename(file))
  
  # KEY: Look at the way your files are named and what parts you want as tree IDs and update the parts and GIS_ID naming accordingly
  parts <- strsplit(full_name, "_")[[1]]
  
  GIS_ID <- full_name
  ID_number <- paste(parts[2], parts[3], parts[4], sep = "_")
  # Return results including ID_number
  return(list(
    GIS_ID = GIS_ID,
    ID_number = ID_number,
    hull = hull,
    pa = pa,
    height = height
  ))
}


# Process all files
results <- lapply(files, process_file)
```

```{r}
# Combine all hulls into an sf object
hulls_sf <- do.call(rbind, lapply(results, function(res) {
  if (!is.na(res$pa)) {
    # Extract the geometry from the hull
    geometry <- st_geometry(res$hull)
    
    # Create an sf object
    st_sf(
      GIS_ID = res$GIS_ID,
      ID_number = res$ID_number,
      area = as.numeric(res$pa),
      area = res$pa,
      geometry = geometry
    )
  } else {
    NULL
  }
}))

# Make sure projection is projected for distance calculations (e.g. UTM)
st_crs(hulls_sf) <- 32355
```

```{r}
# Build neighbors list (IDs of overlapping or within 1 meter)
neighbor_list <- lapply(1:nrow(hulls_sf), function(i) {
  this_tree <- hulls_sf[i, ]
  cat("Processing tree ID:", this_tree$ID_number, "\n")
  
  other_trees <- hulls_sf[-i, ]
  
  overlaps <- st_intersects(this_tree, other_trees, sparse = FALSE)[1, ]
  within_1m <- st_is_within_distance(this_tree, other_trees, dist = 1)[[1]]
  
  neighbor_indices <- union(which(overlaps), within_1m)
  neighbors <- other_trees$ID_number[neighbor_indices]
  
  if (length(neighbors) == 0) {
    NA_character_
  } else {
    paste(neighbors, collapse = ",")
  }
})


hulls_sf$neighbors <- unlist(neighbor_list)
hulls_sf$neighbors_truncated <- nchar(hulls_sf$neighbors) > 254 #shapefiles are limited to 254 characters per cell, so this acts as a warning to look in the full dataframe for any extra neighbors if necessary (e.g. if you load the shapefile into QGIS and visualise target tree and neighbors). If using the find_most_neighbors.R script, you can load in the .Rdata saved at the end which isn't limited in characters
```


```{r}
# Save hulls to a shapefile
st_write(hulls_sf, "S:/qfl_australia_tls/Whyanbeel/Whyanbeel_crowns.shp", delete_layer = TRUE)

# Save metadata to csv
hulls_df <- as.data.frame(hulls_sf)
save(hulls_df, file = "S:/qfl_australia_tls/Whyanbeel/Whyanbeel_crowns.Rdata")
```



